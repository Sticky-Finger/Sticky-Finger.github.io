---
title: 16 类型检查机制（2）：类型兼容性
date: 2019-12-01 11:59:55
tags: TypeScript
---
# 定义:当一个类型Y可以被赋值给另一个类型X时，我们就可以说类型X兼容类型Y

> X兼容: X(目标类型) = Y(源类型)



```ts
let s: string = 'a' // 关闭tsconfig.json中strictNullChecks,字符串变量可赋值给null
s = null;
```

## 接口兼容性

```ts
// 接口兼容性
interface X {
    a: any;
    b: any;
}
interface Y {
    a: any;
    b: any;
    c: any;
}
let x: X = { a: 1, b: 2 };
let y: Y = { a: 1, b: 2, c: 3 }
x = y; // ok,x兼容y
// y = x; // fail
```
- #### 接口之间兼容时，成员少的兼容成员多的

## 函数兼容性
函数兼容的三个条件（要同时满足三个条件）:
- 1)参数个数
    - #### 目标函数的参数个数一定要多余原函数的参数个数——参数多的兼容参数少的  
```ts
type Handler = (a: number, b: number) => void;
function hof(handler: Handler) {
    return handler;
}

// 1)参数个数
let handler1 = (a: number) => {};
hof(handler1);
let handler2 = (a: number, b: number, c: number) => {};
// hof(handler2)

// 以上函数的参数数量是固定的

// 可选参数和剩余参数
let a = (p1: number, p2: number) => {};
let b = (p1?: number, p2?: number) => {};
let c = (...args: number[]) => {};
// a)固定参数是可以兼：容可选参数和剩余参数的
a = b;
a = c;
// b)可选参数不兼容：固定参数和剩余参数
// b = c; // 不兼容
// b = a; // 不兼容
// - 通过关闭tsconfig.json中strictFunctionTypes（设为false），使得b和a、c兼容
// c)剩余参数可以兼容：固定参数和可选参数
c = a;
c = b;
```

- 2)参数类型
    - #### 参数类型成员个数多的兼容成员个数少的
```ts
// 2)参数类型
let handler3 = (a: string) => {};
// hof(handler3);

interface Point3D {
    x: number;
    y: number;
    z: number;
}
interface Point2D {
    x: number;
    y: number;
}
let p3d = (point: Point3D) => {};
let p2d = (point: Point2D) => {};
p3d = p2d; // p3d兼容p2d
p2d = p3d; // 不兼容
// 成员个数多的兼容成员个数少的
// 与接口间的兼容相反
// 函数参数类型接口看作多个参数（拆分成多个参数），和函数兼容一直，参数多的兼容参数少的

// 要让p2d兼容p3d，需要关闭tsconfig.json中strictFunctionTypes（设为false）——这种函数的参数之间可以相互赋值的情况，叫做函数参数的双向协变（这种情况允许把一个精确的类型赋值给一个不那么精确的类型,因而不需要把一个不精确的类型断言成精确类型）
```
- 3)返回值类型
    - #### 目标函数的返回值类型必须与原函数的返回值相同，或者为其子类型——成员少的兼容成员多的

```ts
let f = () => ({ name: 'Alice' });
let g = () => ({ name: 'Alice', location: 'Beijing' });
f = g; // f的返回值类型是g返回值类型的子类型
g = f; // 不兼容
```

函数重载

```ts
// 重载列表
function overload(a: number, b: number): number;
function overload(a: string, b: string): string;
// 具体实现
function overload(a: any, b: any): any {}
// fucntion overload(a: any, b: any, c: any): any {} // 增加一个参数，不兼容(参数多的兼容参数少的)
// function overload(a: any, b: any) {} // 去除返回值类型，不兼容（返回值参数数少的兼容参数多的）
```
- 列表中的函数就是原函数，具体实现就是目标函数
- a)重载列表中，目标函数的参数要多于重载函数的参数，且返回值类型也要符合相应要求


## 枚举类型的兼容性

- 1)枚举类型和数值类型是可以完全相互兼容
-
```ts
enum Fruit { Apple, Banana };
enum Color { Red, Yellow };
let fruit: Fruit.Apple = 3;
let no: number = Fruit.Apple
```

- 2)枚举之间完全不兼容
```ts
let color: Color.Red = Fruit.Apple // 不兼容
```


## 类的兼容性
> 和接口类似，只比较结构

- 注意：类的方法（成员函数）是不参与比较的

```ts
class A {
    constructor(p: number, q: number) {}
    id: number = 1;
}
class B {
    static s = 1;
    constructor(p: number) {}
    id: number = 2;
}
let aa = new A(1, 2);
let bb = new B(1);
aa = bb;
bb = aa;
// 两个实例是完全兼容的，因为它们有相同的实例属性；
// 构造函数和静态成员是不做为比较的
```

- 类中有私有成员
```
class A {
    constructor(p: number, q: number) {}
    id: number = 1;
    private name: string = '';
}
class B {
    static s = 1;
    constructor(p: number) {}
    id: number = 2;
    private name: string = '';
}
let aa = new A(1, 2);
let bb = new B(1);
aa = bb; // 不兼容
bb = aa; // 不兼容
// 这个时候，只有父类和子类是可以相互兼容的
class C extends A {}
let cc = new C(1, 2)
aa = cc;
cc = aa;
// 这时，父类和子类的实例是可以完全兼容的
```

## 泛型的兼容性
- 泛型接口的兼容性
    - #### 只有类型参数（e.g. T）被接口成员使用的时候，才会影响泛型的兼容性
```ts
// interface Empty<T> {}; // 接口没有类型成员
// let obj1: Empty<number> = {};
// let obj2: Empty<string> = {};
// obj1 = obj2; // 完全兼容，因为泛型接口中没有成员

interface Empty<T> {
    value: T;
}
let obj1: Empty<number> = {};
let obj2: Empty<string> = {};
obj1 = obj2; // 不兼容
```

- 泛型函数的兼容性
    - #### 如果两个泛型函数的定义相同，但是没有指定类型参数，那么它们之间是可以相互兼容的 
```ts
let log1 = <T>(x: T): T => {
    console.log(x);
    return x;
};
let log2 = <U>(y: U): U => {
    console.log('y');
    return y;
};
log1 = log2; // 完全兼容
```

## 小结

口诀：
- #### 结构之间兼容：成员少的兼容成员多的
- #### 函数之间兼容：参数多的兼容参数少的