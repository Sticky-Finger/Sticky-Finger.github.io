---
title: 15：类型检查机制（1）：类型推断
date: 2019-12-01 11:57:30
tags: TypeScript
---
类型检查机制:
TypeScript编译器在做类型检查时，所秉承的一些原则，以及表现出的一些行为

作用:辅助开发，提高开发效率
- 类型推断
- 类型兼容性
- 类型保护


> 不需要指定变量的类型（函数的返回值类型），TypeScript可以根据某些规则自动地为其推断出一个类型
- 基础类型推断
- 最佳通用类型推断
- 上下文类型推断

```ts
// 1.基础类型推断
let a = 1; // a的类型推断为number
let b = [1, null]; // (1)tsconfig.json中设置"strictNullChecks": true时，(2.最佳通用类型推断)推断为[number | null]; (2)'strictNullChecks'设为false时，推断为[number]
// 设置函数默认参数时
let c = (x = 1) => x + 1; // c的返回值类型被推断为number,(根据表达式右侧的值来推断表达式左侧的类型)
```
- #### 上面的都是从右到左推断，从左到右推断--上下文类型推断(同常出现在事件处理中):
```ts
window.onkeydown = (event) => { // event推断为事件类型
    // console.log(event.button) // 会推断出event有什么属性，button不是键盘事件的属性
}
```
## 类型断言
> ts 的类型推断不符合预期时，覆盖系统的类型推断

```ts
let foo = {};
foo.bar = 1; // 报错，提示foo没有定义bar属性
```
解决方式:
```ts
interface Foo {
    bar: number;
}
let foo = {} as Foo;
// foo.bar = 1; // 去除对foo属性的赋值，也不报错(没有严格按接口约定赋值，此时，类型断言被滥用了)
foo.bar = 1;
```

- #### 解决断言导致不严格赋值却能通过类型检查这个问题:
```ts
interface Foo {
    bar: number;
}
let foo: Foo = { bar: 1 }; // 声明变量时，直接指定类型
```
- 类型推断，能增加代码灵活性，在改造旧代码时十分有用，
- 使用类型断言要避免滥用，要对上下文环境有充足的预判，没有任何根据的类型断言会对代码带来安全隐患
## 小结:
- ts类型推断能给我们带来重要的辅助信息